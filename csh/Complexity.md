# 시간복잡도와 공간복잡도(Time Complexity Space Complexity)

## 알고리즘의 효율성
 big-O 시간은 알고리즘의 효율성을 나타내는 지표 또는 언어입니다. 이를 제대로 이해하지 못하면 큰 고비를 겪을 수 있습니다.
 예를 들어 디스크에 있는 파일을 보낼 때 용량이 작다면 당연히 어떤 방법이든지 비슷하겠지만 크기가 매우 크다면 온라인보다 물리적으로 배달하는 것이 더 빠를수도 있습니다.
 파일의 크기를 데이터의 양이라고 생각하면 알고리즘에서도 어떤 알고리즘을 사용해야하는지가 매우 중요하다고 볼 수 있습니다.

## 시간 복잡도
 위와 같은 점근적 실행 시간, 또는 big-O 시간이라고 합니다.
 데이터 전송 알고리즘의 실행 시간을 다음과 같이 설명할 수 있는데요.

 1. 온라인 전송 : O(s) -> 이 떄, s는 파일의 크기가 된다. 즉 파일의 크기가 증가하면 전송 시간 또한 선형적으로 존재합니다.
 2. 비행기를 통한 전송 : O(1) -> 파일의 크기와 상관 없이 전송 시간은 언제나 같습니다.

그 외에도 O(n), O(n^2), O(nlogn)등으로 나타낼 수 있는데 사용 용도에 맞게 알맞게 사용하는 것이 효율성에 매우 도움이 됩니다.

![image](https://user-images.githubusercontent.com/39639429/158044200-467e8bbf-c26a-42b5-b527-be4170e38555.png)


### big-O, big-theta, big-omega
 학계에서는 수행 시간을 표기할 때 위의 세가지 용어를 사용합니다
 1. big-O : 시간의 상한을 나타냅니다. 배열의 모든 값을 출력하는 알고리즘은 O(N)으로 표현하지만 N보다 큰 O(N^2), O(2^N) 등으로도 표현이 가능합니다.
 2. big-omega : omega는 등가 또는 하한을 나타냅니다. 배열의 모든 값을 출력하는 알고리즘은 일반적으로 omega(N)이지만 최소 수행 시간을 계산하면 omega(logN), omega(1) 등으로 나타낼 수 있습니다.
 3. big-theta : 위 O와 omega 두 개를 전부 의미합니다.

### 최선, 최악, 평균적인 경우
 실제로 알고리즘은 세 가지 다른 방법으로 나타낼 수 있습니다.
 퀵 정렬로 예를 들어보겠습니다. 퀵 정렬은 축이 되는 원소 하나를 뽑아 해당 수보다 작은 수는 앞으로, 큰 원소는 뒤로가게하여 재귀적으로 정렬하는 알고리즘입니다.
 1. 최선의 경우 : 모든 원소가 동일하다면 퀵 정렬은 배열을 1회 순회한 뒤 종료하게 될 것입니다. 즉, 수행시간은 O(N)이 됩니다.
 2. 최악의 경우 : 정말 운이 없게도 배열에서 가장 큰 원소가 축이 된다면 시간은 N + N-1 + N-2 ... 1이 될 것입니다. 이는 시간복잡도상으로 O(N^2)이 됩니다.
 3. 평균적인 경우 : 위와 같은 경우가 반복적으로 발생하는 경우는 드물기에 평균 시간복잡도는 O(NlogN)이 됩니다.

## 공간복잡도
 알고리즘에서는 시간뿐만이 아닌 공간, 즉 메모리또한 신경써야합니다.
 공간복잡도는 시간 복잡도와 평행선을 달리는 개념으로 만약 크기가 N인 배열을 만든다면 O(N)의 공간이, N X N 배열을 만든다면 O(n^2)의 공간이 필요합니다.
 재귀 호출에서 사용되는 스택 공간 또한 공간 복잡도 계산에 포함됩니다. 예를 들어보겠습니다.
 int sum(int n){
 if(n<=0) return 0;
 return n + sum(n-1)}
 위와 같은 코드는 sum(5) -> sum(4) -> sum(3) -> sum(2) -> sum(1) -> sum(0) 식으로 호출시마다 스택의 깊이가 깊어지므로 그만큼의 공간이 필요해 O(n)의 공간이 필요합니다.

 반대로 n번 호출했다고 O(n)의 공간이 필요한 것은 아닙니다. 다시 한번 예를 들어보겠습니다.
 int sum(int n){
 int sum=0;
 for(int i=0; i<n; i++){
 sum += pairsum(i, i+1);}
 return sum}

 int pairsum(int i, int j){return i+j}

 위와 같은 코드는 O(n)번 호출되었지만 이 함수가 호출 스택을 쌓지 않고 하나의 공간에서 이루워지므로 O(1)의 공간 복잡도를 가집니다.

#Time Complexity vs Space Complexity
시간 복잡도는 “얼마나 빠르게 실행되느냐” 그리고 공간 복잡도는 “얼마나 많은 자원이 필요한가?”
정리해보자면, 좋은 알고리즘이란, “시간도 적게 걸리고 자원의 사용도 적어야 하는 것!"

결국 우리가 이를 실질적으로 적용해서 사용하기 위해서는 어떤 알고리즘이 어떤 big-O 시간복잡도를 가지고 특정 상황에서 효율적인지 알아야하며
재귀적으로 함수 사용시에 발생할 수 있는 스택의 관리가 중요한 부분으로 작용하게 됩니다.
